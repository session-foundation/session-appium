diff --git a/lib/runner/dispatcher.js b/lib/runner/dispatcher.js
index 4bc72b7cfd69e539b1250498bed35db8fc168fb7..8490cd06b2b9d583072c967c8a58ce20dcee4c97 100644
--- a/lib/runner/dispatcher.js
+++ b/lib/runner/dispatcher.js
@@ -26,6 +26,7 @@ var import_utils2 = require("playwright-core/lib/utils");
 var import_rebase = require("./rebase");
 var import_workerHost = require("./workerHost");
 var import_ipc = require("../common/ipc");
+
 class Dispatcher {
   constructor(config, reporter, failureTracker) {
     this._workerSlots = [];
@@ -39,49 +40,501 @@ class Dispatcher {
     this._config = config;
     this._reporter = reporter;
     this._failureTracker = failureTracker;
+    this._devicePoolMinAvailable = [];
+    this._statusLogInterval = null;
+
+    // Dynamic worker configuration
+    this._maxWorkers = this._config.config.workers || 12; // Max workers allowed
+    this._minWorkers = 1; // Minimum workers to keep alive
+    this._workerIdleTimeout = 10000; // 10s before killing idle worker
+    this._lastWorkerActivity = new Map(); // Track when workers were last busy
+    this._dynamicWorkerScaling = this._config.config.dynamicWorkerScaling !== false; // Default on
+    
+    console.log(`🎯 [WORKERS] Dynamic scaling enabled: ${this._minWorkers}-${this._maxWorkers} workers`);
+    
     for (const project of config.projects) {
       if (project.workers)
         this._workerLimitPerProjectId.set(project.id, project.workers);
     }
+    
+// ADD: Device pool management with iOS device detection
+    const configuredPoolSize = this._config.config.devicePoolSize || 
+                              parseInt(process.env.PLAYWRIGHT_DEVICE_POOL_SIZE) || 
+                              12; // Default max if not specified
+    
+    // Detect actual available iOS devices
+    const actualDeviceCount = this._detectIosDeviceCount();
+    const devicePoolSize = Math.min(configuredPoolSize, actualDeviceCount);
+    
+    if (actualDeviceCount < configuredPoolSize) {
+      console.warn(
+        `⚠️  [DEVICE_POOL] Configured pool size (${configuredPoolSize}) exceeds actual available devices (${actualDeviceCount}). ` +
+        `Using ${devicePoolSize} devices.`
+      );
+    }
+    
+    this._devicePool = {
+      total: devicePoolSize,
+      available: devicePoolSize,
+      configured: configuredPoolSize,
+      actual: actualDeviceCount,
+      allocations: new Map(),
+      waitQueue: [],
+      deviceStates: new Array(devicePoolSize).fill(false),
+      stats: {
+        totalAllocated: 0,
+        totalQueued: 0,
+        maxQueueSize: 0,
+        totalWaitTime: 0,
+        waitCounts: 0,
+      },
+    };
+    
+    console.log(`🎮 [DEVICE_POOL] Initialized with ${devicePoolSize} devices`);
+    console.log(`    Configured: ${configuredPoolSize}, Actual available: ${actualDeviceCount}, Using: ${devicePoolSize}`);
   }
-  _findFirstJobToRun() {
-    for (let index = 0; index < this._queue.length; index++) {
-      const job = this._queue[index];
-      const projectIdWorkerLimit = this._workerLimitPerProjectId.get(job.projectId);
-      if (!projectIdWorkerLimit)
-        return index;
-      const runningWorkersWithSameProjectId = this._workerSlots.filter((w) => w.busy && w.worker && w.worker.projectId() === job.projectId).length;
-      if (runningWorkersWithSameProjectId < projectIdWorkerLimit)
-        return index;
+
+  _detectActualDeviceCount() {
+    // Check if we're running iOS or Android tests based on projects
+    const hasIosTests = this._config.projects.some(p => 
+      p.name?.toLowerCase().includes('ios') || 
+      p.use?.defaultBrowserType === 'webkit' // or however you identify iOS projects
+    );
+    
+    const hasAndroidTests = this._config.projects.some(p => 
+      p.name?.toLowerCase().includes('android') ||
+      p.use?.defaultBrowserType === 'chromium' // or however you identify Android projects
+    );
+    
+    if (hasIosTests) {
+      return this._detectIosDeviceCount();
+    } else if (hasAndroidTests) {
+      return this._detectAndroidDeviceCount();
     }
+    
+    // Default to checking iOS devices
+    return this._detectIosDeviceCount();
+  }
+
+  _detectIosDeviceCount() {
+    let actualCount = 0;
+    
+    // Check iOS simulator environment variables
+    for (let i = 1; i <= 12; i++) {
+      const udid = process.env[`IOS_${i}_SIMULATOR`];
+      
+      // Check if it's a valid UUID (not placeholder)
+      if (udid && this._isValidIosUdid(udid)) {
+        actualCount++;
+      }
+    }
+    
+    console.log(`🔍 [DEVICE_POOL] Detected ${actualCount} actual iOS devices`);
+    return actualCount;
+  }
+
+  _detectAndroidDeviceCount() {
+    let actualCount = 0;
+    
+    // For Android, you might check differently
+    // This is a placeholder - implement based on your Android setup
+    for (let i = 1; i <= 12; i++) {
+      // Check if Android emulator exists
+      // You might check ANDROID_${i}_EMULATOR or use adb devices
+      actualCount = i; // Placeholder
+    }
+    
+    return Math.min(actualCount, 12);
+  }
+
+  _isValidIosUdid(udid) {
+    // UUID format check
+    const uuidRegex = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;
+    
+    // Check against known placeholders
+    const placeholders = ['just_not_empty', 'placeholder', 'dummy', 'not_set'];
+    
+    return uuidRegex.test(udid) && !placeholders.includes(udid.toLowerCase());
+  }
+
+  _findFirstJobToRun() {
+    // REPLACED: This method is no longer used - we use smarter scheduling
     return -1;
   }
+
   _scheduleJob() {
-    if (this._isStopped)
-      return;
-    const jobIndex = this._findFirstJobToRun();
-    if (jobIndex === -1)
-      return;
-    const job = this._queue[jobIndex];
-    let workerIndex = this._workerSlots.findIndex((w) => !w.busy && w.worker && w.worker.hash() === job.workerHash && !w.worker.didSendStop());
-    if (workerIndex === -1)
+  if (this._isStopped)
+    return;
+  
+  console.log(`\n🔄 [SCHEDULER] Running scheduler (${this._devicePool.available}/${this._devicePool.total} devices available)`);
+  
+  // First, try to run jobs from the wait queue
+  this._processWaitQueue();
+  
+  // Then, try to schedule new jobs from the main queue
+  this._processMainQueue();
+  
+  // Log queue status summary (not every job!)
+  if (this._devicePool.waitQueue.length > 0) {
+    const summary = {};
+    this._devicePool.waitQueue.forEach(item => {
+      const key = `${item.devices}-device`;
+      summary[key] = (summary[key] || 0) + 1;
+    });
+    
+    console.log(`⏳ [QUEUE] ${this._devicePool.waitQueue.length} jobs waiting:`);
+    Object.entries(summary).forEach(([type, count]) => {
+      console.log(`    ${count} ${type} tests`);
+    });
+    
+    // Show wait times for first few
+    const firstFew = this._devicePool.waitQueue.slice(0, 3);
+    firstFew.forEach((item, i) => {
+      const waitTime = Math.round((Date.now() - item.timestamp) / 1000);
+      const test = item.job.tests?.[0]?.title || 'Unknown';
+      console.log(`    ${i + 1}. "${test}" (${item.devices} devices, ${waitTime}s)`);
+    });
+    
+    if (this._devicePool.waitQueue.length > 3) {
+      console.log(`    ... and ${this._devicePool.waitQueue.length - 3} more`);
+    }
+  }
+}
+
+  _processWaitQueue() {
+  if (this._devicePool.waitQueue.length === 0) return;
+  
+  console.log(`🔍 [QUEUE] Processing wait queue with ${this._devicePool.waitQueue.length} jobs`);
+  
+  // Sort wait queue by device count (ascending) and timestamp (FIFO)
+  this._devicePool.waitQueue.sort((a, b) => {
+    if (a.devices !== b.devices) return a.devices - b.devices;
+    return a.timestamp - b.timestamp;
+  });
+  
+  const stillWaiting = [];
+  let stopChecking = false;
+  
+  for (const item of this._devicePool.waitQueue) {
+    // If we already know we can't schedule this size, skip the rest
+    if (stopChecking || item.devices > this._devicePool.available) {
+      stillWaiting.push(item);
+      // Once we hit a job we can't run, all larger jobs also can't run
+      stopChecking = true;
+      continue;
+    }
+    
+    console.log(`   Trying to schedule job needing ${item.devices} devices...`);
+    if (this._tryScheduleJob(item.job, item.devices)) {
+      const waitTime = Date.now() - item.timestamp;
+      console.log(
+        `✅ [QUEUE] Job waited ${Math.round(waitTime / 1000)}s before running`,
+      );
+      // UPDATE STATS
+      this._devicePool.stats.totalWaitTime += waitTime;
+      this._devicePool.stats.waitCounts++;
+      // Don't add to stillWaiting - it's been scheduled!
+    } else {
+      console.log(`   Still not enough devices (need ${item.devices}, have ${this._devicePool.available})`);
+      stillWaiting.push(item);
+      // If we can't run this job, we can't run any larger jobs either
+      stopChecking = true;
+    }
+  }
+  
+  this._devicePool.waitQueue = stillWaiting;
+  
+  // Log a summary instead of listing every waiting job
+  if (stillWaiting.length > 0) {
+    const deviceCounts = {};
+    stillWaiting.forEach(item => {
+      deviceCounts[item.devices] = (deviceCounts[item.devices] || 0) + 1;
+    });
+    
+    console.log(`⏳ [QUEUE] ${stillWaiting.length} jobs waiting:`);
+    Object.entries(deviceCounts).forEach(([devices, count]) => {
+      console.log(`    ${count} jobs need ${devices} devices`);
+    });
+  }
+}
+
+ _processMainQueue() {
+  const remainingJobs = [];
+  
+  // Track the minimum devices needed that we've already queued
+  let minDevicesQueued = Infinity;
+  
+  for (const job of this._queue) {
+    const devices = this._getJobDeviceRequirement(job);
+    
+    // Check project worker limits first
+    if (!this._canRunBasedOnProjectLimits(job)) {
+      remainingJobs.push(job);
+      continue;
+    }
+    
+    // If we already queued a job needing fewer devices than this one,
+    // and it couldn't run, then this one definitely can't run either
+    if (devices > 0 && devices >= minDevicesQueued && devices > this._devicePool.available) {
+      // Skip the scheduling attempt and go straight to queue
+      this._devicePool.waitQueue.push({
+        job,
+        devices,
+        timestamp: Date.now()
+      });
+      this._devicePool.stats.totalQueued++;
+      this._devicePool.stats.maxQueueSize = Math.max(
+        this._devicePool.stats.maxQueueSize,
+        this._devicePool.waitQueue.length
+      );
+      continue;
+    }
+    
+    // Try to schedule immediately
+    if (this._tryScheduleJob(job, devices)) {
+      console.log(`🚀 [SCHEDULER] Immediately scheduled job needing ${devices} devices`);
+    } else if (devices > 0) {
+      // Add to wait queue and track minimum devices
+      this._devicePool.waitQueue.push({
+        job,
+        devices,
+        timestamp: Date.now()
+      });
+      this._devicePool.stats.totalQueued++;
+      this._devicePool.stats.maxQueueSize = Math.max(
+        this._devicePool.stats.maxQueueSize,
+        this._devicePool.waitQueue.length
+      );
+      
+      // Update minimum devices that couldn't run
+      minDevicesQueued = Math.min(minDevicesQueued, devices);
+      
+      // Don't log every single queue addition
+      if (this._devicePool.waitQueue.length === 1 || this._devicePool.waitQueue.length % 10 === 0) {
+        console.log(`📋 [QUEUE] Queue size: ${this._devicePool.waitQueue.length} jobs`);
+      }
+    } else {
+      // Jobs with 0 devices should wait for available worker
+      remainingJobs.push(job);
+    }
+  }
+  
+  this._queue = remainingJobs;
+}
+
+  _canRunBasedOnProjectLimits(job) {
+    const projectIdWorkerLimit = this._workerLimitPerProjectId.get(job.projectId);
+    if (!projectIdWorkerLimit) return true;
+    
+    const runningWorkersWithSameProjectId = this._workerSlots.filter(
+      (w) => w.busy && w.worker && w.worker.projectId() === job.projectId
+    ).length;
+    
+    return runningWorkersWithSameProjectId < projectIdWorkerLimit;
+  }
+
+  _tryScheduleJob(job, devices) {
+    console.log(`🔍 [TRY_SCHEDULE] Trying to schedule job needing ${devices} devices (${this._devicePool.available} available)`);
+    
+    // Validate device requirement against actual devices
+    if (devices > this._devicePool.actual) {
+      console.error(
+        `❌ [ERROR] Job requires ${devices} devices but only ${this._devicePool.actual} actual devices exist`
+      );
+      
+      // Provide helpful error message
+      const errorMsg = this._devicePool.actual < this._devicePool.configured
+        ? `Test requires ${devices} devices but only ${this._devicePool.actual} are actually available. ` +
+          `Check your IOS_*_SIMULATOR environment variables - only ${this._devicePool.actual} have valid UDIDs.`
+        : `Test requires ${devices} devices but pool only has ${this._devicePool.total} total`;
+      
+      this._failJobWithErrors(job, [{ message: errorMsg }]);
+      return true; // Mark as "scheduled" so it's removed from queue
+    }
+    
+    // Check device availability
+    if (devices > this._devicePool.available) {
+      console.log(`   ❌ Not enough devices`);
+      return false;
+    }
+    
+    // Find available worker
+    let workerIndex = this._workerSlots.findIndex(
+      (w) => !w.busy && w.worker && w.worker.hash() === job.workerHash && !w.worker.didSendStop()
+    );
+    if (workerIndex === -1) {
       workerIndex = this._workerSlots.findIndex((w) => !w.busy);
+    }
+    
     if (workerIndex === -1) {
-      return;
+      console.log(`   ❌ No available workers (all ${this._workerSlots.length} are busy)`);
+      console.log(`   Worker states:`, this._workerSlots.map((w, i) => `Worker ${i}: ${w.busy ? 'busy' : 'idle'}`));
+      return false;
     }
-    this._queue.splice(jobIndex, 1);
-    const jobDispatcher = new JobDispatcher(job, this._reporter, this._failureTracker, () => this.stop().catch(() => {
-    }));
+    
+    console.log(`   ✅ Found available worker ${workerIndex}`);
+    
+    if (devices > 0) {
+        // Allocate specific device indices (not just count)
+        const allocatedIndices = this._allocateDeviceIndices(devices);
+        if (!allocatedIndices) return false;
+        
+        this._devicePool.available -= devices;
+        this._devicePool.allocations.set(workerIndex, { 
+          devices, 
+          indices: allocatedIndices,
+          job 
+        });
+        
+        // Pass indices to the job so worker can access them
+        job.allocatedDevices = allocatedIndices;
+        
+        console.log(`🔒 [DEVICES] Worker ${workerIndex} allocated devices: ${allocatedIndices.join(', ')} for job "${job.tests?.[0]?.title}"`);
+        
+        // ADD THIS: Verify the allocation matches what the job needs
+        if (allocatedIndices.length !== devices) {
+          console.error(`❌ [DEVICES] Allocation mismatch! Job needs ${devices} but got ${allocatedIndices.length}`);
+        }
+      
+      // Track stats
+      this._devicePoolMinAvailable.push(this._devicePool.available);
+      this._devicePool.stats.totalAllocated++;
+    }
+    
+    // Log what we're running
+    const test = job.tests?.[0];
+    if (test) {
+      console.log(`📱 [RUNNING] "${test.title}" on worker ${workerIndex} with ${devices} devices`);
+    }
+    
+    // Set up job dispatcher
+    const jobDispatcher = new JobDispatcher(
+      job,
+      this._reporter,
+      this._failureTracker,
+      () => this.stop().catch(() => {})
+    );
+    
     this._workerSlots[workerIndex].busy = true;
     this._workerSlots[workerIndex].jobDispatcher = jobDispatcher;
     void this._runJobInWorker(workerIndex, jobDispatcher).then(() => {
+      // Deallocate devices properly
+      this._deallocateDevices(workerIndex);
+      
       this._workerSlots[workerIndex].jobDispatcher = void 0;
       this._workerSlots[workerIndex].busy = false;
       this._checkFinished();
+      
+      // Try to schedule more work
       this._scheduleJob();
     });
+    
+    return true;
   }
+
+  // Add device index tracking
+  _allocateDeviceIndices(count) {
+    const available = [];
+    
+    // Track which device indices are in use
+    if (!this._devicePool.deviceStates) {
+      this._devicePool.deviceStates = new Array(this._devicePool.total).fill(false);
+    }
+    
+    // Find available devices
+    for (let i = 0; i < this._devicePool.total && available.length < count; i++) {
+      if (!this._devicePool.deviceStates[i]) {
+        available.push(i);
+        this._devicePool.deviceStates[i] = true;
+      }
+    }
+    
+    if (available.length < count) {
+      // Rollback
+      available.forEach(i => this._devicePool.deviceStates[i] = false);
+      return null;
+    }
+    
+    return available;
+  }
+
+  // Update deallocation
+  _deallocateDevices(workerIndex) {
+    const allocation = this._devicePool.allocations.get(workerIndex);
+    if (allocation) {
+      // Free specific device indices
+      allocation.indices.forEach(i => {
+        this._devicePool.deviceStates[i] = false;
+      });
+      
+      this._devicePool.available += allocation.devices;
+      this._devicePool.allocations.delete(workerIndex);
+      console.log(`🔓 [DEVICES] Worker ${workerIndex} released devices: ${allocation.indices.join(', ')}`);
+    }
+  }
+
+  _getJobDeviceRequirement(job) {
+    const test = job.tests?.[0];
+    if (!test) return 0;
+    
+    const deviceMatch = test.title?.match(/@(\d+)-devices/);
+    return deviceMatch ? parseInt(deviceMatch[1]) : 0;
+  }
+
+  _failJobWithErrors(job, errors) {
+    // Helper method to fail a job before it runs
+    for (const test of job.tests) {
+      const result = test._appendTestResult();
+      this._reporter.onTestBegin?.(test, result);
+      result.errors = [...errors];
+      result.error = result.errors[0];
+      result.status = "failed";
+      this._reporter.onTestEnd?.(test, result);
+    }
+  }
+
+  getDevicePoolStatus() {
+    const allocatedDevices = [];
+    this._devicePool.allocations.forEach((allocation, workerIndex) => {
+      allocatedDevices.push({
+        worker: workerIndex,
+        devices: allocation.indices,
+        test: allocation.job.tests?.[0]?.title || 'Unknown',
+      });
+    });
+
+    return {
+      total: this._devicePool.total,
+      available: this._devicePool.available,
+      allocated: this._devicePool.total - this._devicePool.available,
+      allocations: allocatedDevices,
+      queueLength: this._devicePool.waitQueue.length,
+      queuedJobs: this._devicePool.waitQueue.map(item => ({
+        test: item.job.tests?.[0]?.title || 'Unknown',
+        devicesNeeded: item.devices,
+        waitingTime: Math.round((Date.now() - item.timestamp) / 1000),
+      })),
+    };
+  }
+
+  _canAcceptMoreWork() {
+    // Check if we have any idle workers
+    const hasIdleWorker = this._workerSlots.some(w => !w.busy);
+    
+    // Check if we have devices available
+    const hasAvailableDevices = this._devicePool.available > 0;
+    
+    // Check if we have jobs that could run
+    const hasRunnableJobs = this._queue.some(job => {
+      const devices = this._getJobDeviceRequirement(job);
+      return devices <= this._devicePool.available && this._canRunBasedOnProjectLimits(job);
+    }) || this._devicePool.waitQueue.some(item => item.devices <= this._devicePool.available);
+    
+    return hasIdleWorker && hasAvailableDevices && hasRunnableJobs;
+  }
+
   async _runJobInWorker(index, jobDispatcher) {
+    this._lastWorkerActivity.set(index, Date.now());
     const job = jobDispatcher.job;
     if (jobDispatcher.skipWholeJob())
       return;
@@ -108,26 +561,101 @@ class Dispatcher {
     const result = await jobDispatcher.jobResult;
     this._updateCounterForWorkerHash(job.workerHash, -1);
     if (result.didFail)
-      void worker.stop(
-        true
-        /* didFail */
-      );
+      void worker.stop(true);
     else if (this._isWorkerRedundant(worker))
       void worker.stop();
     if (!this._isStopped && result.newJob) {
       this._queue.unshift(result.newJob);
       this._updateCounterForWorkerHash(result.newJob.workerHash, 1);
     }
+    this._lastWorkerActivity.set(index, Date.now());
+  }
+
+  // Optimized test ordering for dynamic workers
+  _optimizeTestOrderDynamic(testGroups) {
+    const testsByDeviceCount = {};
+    testGroups.forEach(group => {
+      const devices = this._getJobDeviceRequirement(group);
+      if (!testsByDeviceCount[devices]) {
+        testsByDeviceCount[devices] = [];
+      }
+      testsByDeviceCount[devices].push(group);
+    });
+    
+    const optimizedOrder = [];
+    
+    // Dynamic strategy: Start with whatever maximizes throughput
+    // Priority: 1-device tests (max parallelism), then 2-device, then larger
+    
+    // Interleave different sizes for continuous high utilization
+    let hasMore = true;
+    while (hasMore) {
+      hasMore = false;
+      
+      // Add one test of each size in each round
+      for (let devices = 1; devices <= this._devicePool.total; devices++) {
+        if (testsByDeviceCount[devices]?.length > 0) {
+          optimizedOrder.push(testsByDeviceCount[devices].shift());
+          hasMore = true;
+        }
+      }
+    }
+    
+    // Add any remaining 0-device tests
+    if (testsByDeviceCount[0]) {
+      optimizedOrder.push(...testsByDeviceCount[0]);
+    }
+    
+    console.log('🧠 [OPTIMIZER] Using dynamic strategy for flexible worker scaling');
+    
+    return optimizedOrder;
   }
+
   _checkFinished() {
     if (this._finished.isDone())
       return;
-    if (this._queue.length && !this._isStopped)
+    
+    // Not finished if we have jobs in main queue or wait queue
+    if ((this._queue.length || this._devicePool.waitQueue.length) && !this._isStopped)
       return;
+      
     if (this._workerSlots.some((w) => w.busy))
       return;
+    
+    // Clear status interval if running
+    if (this._statusLogInterval) {
+      clearInterval(this._statusLogInterval);
+      this._statusLogInterval = null;
+    }
+    
+    // Clean up worker management
+    if (this._workerManagementInterval) {
+      clearInterval(this._workerManagementInterval);
+      this._workerManagementInterval = null;
+    }
+
+    // Log final stats
+    if (this._devicePool.stats.totalQueued > 0 || this._devicePool.configured !== this._devicePool.actual) {
+      const avgWaitTime = this._devicePool.stats.waitCounts > 0 
+        ? this._devicePool.stats.totalWaitTime / this._devicePool.stats.waitCounts
+        : 0;
+      
+      console.log("\n📊 [STATS] Device Pool Statistics:");
+      console.log(`    Device pool configuration:`);
+      console.log(`      - Configured size: ${this._devicePool.configured}`);
+      console.log(`      - Actual available: ${this._devicePool.actual}`);
+      console.log(`      - Used in pool: ${this._devicePool.total}`);
+      console.log(`    Runtime statistics:`);
+      console.log(`      - Total allocations: ${this._devicePool.stats.totalAllocated}`);
+      console.log(`      - Jobs queued: ${this._devicePool.stats.totalQueued}`);
+      console.log(`      - Max queue size: ${this._devicePool.stats.maxQueueSize}`);
+      console.log(`      - Avg wait time: ${Math.round(avgWaitTime / 1000)}s`);
+      console.log(`      - Peak device usage: ${this._devicePool.total - Math.min(...this._devicePoolMinAvailable || [this._devicePool.total])}`);
+    }
+    
     this._finished.resolve();
   }
+
   _isWorkerRedundant(worker) {
     let workersWithSameHash = 0;
     for (const slot of this._workerSlots) {
@@ -136,29 +664,242 @@ class Dispatcher {
     }
     return workersWithSameHash > this._queuedOrRunningHashCount.get(worker.hash());
   }
+
   _updateCounterForWorkerHash(hash, delta) {
     this._queuedOrRunningHashCount.set(hash, delta + (this._queuedOrRunningHashCount.get(hash) || 0));
   }
-  async run(testGroups, extraEnvByProjectId) {
-    this._extraEnvByProjectId = extraEnvByProjectId;
-    this._queue = testGroups;
+
+async run(testGroups, extraEnvByProjectId) {
+  this._extraEnvByProjectId = extraEnvByProjectId;
+  
+  // Smart ordering for optimal device utilization
+  this._queue = this._optimizeTestOrder(testGroups);
+  
+  // Log device requirements summary
+  console.log('\n🎬 [DISPATCHER] Starting run with test groups:');
+  const deviceCounts = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 };
+  this._queue.forEach((group, i) => {
+    const devices = this._getJobDeviceRequirement(group);
+    deviceCounts[devices]++;
+    if (i < 5) {  // Show first 5 for brevity
+      group.tests.forEach(test => {
+        console.log(`    - "${test.title}" (${devices} devices)`);
+      });
+    }
+  });
+    
+    console.log(`\n📊 [SUMMARY] Device requirements:`);
+    Object.entries(deviceCounts).forEach(([devices, count]) => {
+      if (count > 0) {
+        console.log(`    ${devices} devices: ${count} tests`);
+      }
+    });
+    
     for (const group of testGroups)
       this._updateCounterForWorkerHash(group.workerHash, 1);
+    
     this._isStopped = false;
     this._workerSlots = [];
+    
     if (this._failureTracker.hasReachedMaxFailures())
       void this.stop();
-    for (let i = 0; i < this._config.config.workers; i++)
+    
+    // Start with optimal number of workers based on initial queue
+    const optimalWorkers = this._calculateOptimalWorkerCount();
+    console.log(`🚀 [WORKERS] Starting with ${optimalWorkers} workers`);
+
+    for (let i = 0; i < optimalWorkers; i++)
       this._workerSlots.push({ busy: false });
+    
+    // Start the scheduler for initial workers
     for (let i = 0; i < this._workerSlots.length; i++)
       this._scheduleJob();
+    
+    // Start worker management loop
+    if (this._dynamicWorkerScaling) {
+      this._startWorkerManagement();
+    }
+    
     this._checkFinished();
     await this._finished;
   }
+
+_calculateOptimalWorkerCount() {
+    if (!this._dynamicWorkerScaling) {
+      return this._config.config.workers;
+    }
+    
+    // Analyze the queue to determine optimal worker count
+    const queueAnalysis = this._analyzeQueue();
+    const { deviceCounts, totalTests } = queueAnalysis;
+    
+    // Calculate how many workers we can efficiently use
+    let optimalWorkers = 0;
+    
+    // For 1-device tests: up to poolSize workers
+    if (deviceCounts[1] > 0) {
+      optimalWorkers = Math.min(deviceCounts[1], this._devicePool.total, this._maxWorkers);
+    }
+    
+    // For 2-device tests: up to poolSize/2 workers
+    if (deviceCounts[2] > 0) {
+      const possible2Workers = Math.floor(this._devicePool.total / 2);
+      optimalWorkers = Math.max(optimalWorkers, Math.min(deviceCounts[2], possible2Workers, this._maxWorkers));
+    }
+    
+    // For larger tests: be conservative
+    const largeTests = Object.entries(deviceCounts)
+      .filter(([devices]) => parseInt(devices) > 2)
+      .reduce((sum, [_, count]) => sum + count, 0);
+    
+    if (largeTests > 0) {
+      // At least 2 workers for large tests
+      optimalWorkers = Math.max(optimalWorkers, Math.min(2, this._maxWorkers));
+    }
+    
+    // Never exceed total test count
+    optimalWorkers = Math.min(optimalWorkers, totalTests);
+    
+    // Start with at least minWorkers
+    return Math.max(this._minWorkers, optimalWorkers);
+  }
+
+  _analyzeQueue() {
+    const deviceCounts = {};
+    let totalTests = 0;
+    
+    [...this._queue, ...this._devicePool.waitQueue.map(item => item.job)].forEach(job => {
+      const devices = this._getJobDeviceRequirement(job);
+      deviceCounts[devices] = (deviceCounts[devices] || 0) + 1;
+      totalTests++;
+    });
+    
+    return { deviceCounts, totalTests };
+  }
+
+  _startWorkerManagement() {
+    this._workerManagementInterval = setInterval(() => {
+      this._adjustWorkerPool();
+    }, 5000); // Check every 5 seconds
+  }
+
+  _adjustWorkerPool() {
+    if (this._isStopped) return;
+    
+    const activeWorkers = this._workerSlots.filter(w => w.busy).length;
+    const idleWorkers = this._workerSlots.length - activeWorkers;
+    const queuedJobs = this._queue.length + this._devicePool.waitQueue.length;
+    
+    console.log(`\n⚙️  [WORKERS] Status: ${activeWorkers} active, ${idleWorkers} idle, ${queuedJobs} queued`);
+    
+    // Scale up if we have queued jobs and available devices
+    if (queuedJobs > 0 && this._devicePool.available > 0 && this._workerSlots.length < this._maxWorkers) {
+      const canAddWorkers = this._calculateWorkersToAdd();
+      if (canAddWorkers > 0) {
+        console.log(`📈 [WORKERS] Scaling up: adding ${canAddWorkers} workers`);
+        for (let i = 0; i < canAddWorkers; i++) {
+          this._addWorker();
+        }
+      }
+    }
+    
+    // Scale down if we have too many idle workers
+    if (idleWorkers > 1 && this._workerSlots.length > this._minWorkers) {
+      const toRemove = this._calculateWorkersToRemove();
+      if (toRemove > 0) {
+        console.log(`📉 [WORKERS] Scaling down: removing ${toRemove} idle workers`);
+        this._removeIdleWorkers(toRemove);
+      }
+    }
+  }
+
+  _calculateWorkersToAdd() {
+    const { deviceCounts } = this._analyzeQueue();
+    const currentWorkers = this._workerSlots.length;
+    
+    // Check what we can run with available devices
+    let possibleNewWorkers = 0;
+    
+    // Can we run more 1-device tests?
+    if (deviceCounts[1] > 0 && this._devicePool.available >= 1) {
+      possibleNewWorkers = Math.min(
+        deviceCounts[1],
+        this._devicePool.available,
+        this._maxWorkers - currentWorkers
+      );
+    }
+    
+    // Can we run more 2-device tests?
+    if (deviceCounts[2] > 0 && this._devicePool.available >= 2) {
+      const possible2Workers = Math.floor(this._devicePool.available / 2);
+      possibleNewWorkers = Math.max(
+        possibleNewWorkers,
+        Math.min(possible2Workers, this._maxWorkers - currentWorkers)
+      );
+    }
+    
+    return possibleNewWorkers;
+  }
+
+  _calculateWorkersToRemove() {
+    const idleWorkers = this._workerSlots.filter((w, i) => {
+      if (w.busy) return false;
+      
+      // Check how long this worker has been idle
+      const lastActive = this._lastWorkerActivity.get(i) || Date.now();
+      const idleTime = Date.now() - lastActive;
+      
+      return idleTime > this._workerIdleTimeout;
+    });
+    
+    // Keep at least minWorkers
+    const maxCanRemove = this._workerSlots.length - this._minWorkers;
+    return Math.min(idleWorkers.length, maxCanRemove);
+  }
+
+  _addWorker() {
+    const newIndex = this._workerSlots.length;
+    this._workerSlots.push({ busy: false });
+    this._lastWorkerActivity.set(newIndex, Date.now());
+    
+    // Immediately try to schedule work for the new worker
+    this._scheduleJob();
+  }
+
+  _removeIdleWorkers(count) {
+    let removed = 0;
+    
+    // Remove from the end, prefer removing workers that have been idle longest
+    for (let i = this._workerSlots.length - 1; i >= 0 && removed < count; i--) {
+      const slot = this._workerSlots[i];
+      if (!slot.busy && !slot.worker) {
+        this._workerSlots.splice(i, 1);
+        this._lastWorkerActivity.delete(i);
+        removed++;
+      }
+    }
+  }
+
+
   _createWorker(testGroup, parallelIndex, loaderData) {
     const projectConfig = this._config.projects.find((p) => p.id === testGroup.projectId);
     const outputDir = projectConfig.project.outputDir;
-    const worker = new import_workerHost.WorkerHost(testGroup, parallelIndex, loaderData, this._extraEnvByProjectId.get(testGroup.projectId) || {}, outputDir);
+    
+    // FIX: Get the allocated devices from the JOB, not from the worker's parallel index
+    // The job should have allocatedDevices set by _tryScheduleJob
+    const extraEnv = {
+      ...(this._extraEnvByProjectId.get(testGroup.projectId) || {}),
+      // Use the devices allocated to this specific job
+      ALLOCATED_DEVICES: testGroup.allocatedDevices ? JSON.stringify(testGroup.allocatedDevices) : '[]'
+    };
+    
+    const worker = new import_workerHost.WorkerHost(
+      testGroup, 
+      parallelIndex, 
+      loaderData, 
+      extraEnv,
+      outputDir
+    );
     const handleOutput = (params) => {
       const chunk = chunkFromParams(params);
       if (worker.didFail()) {
@@ -190,9 +931,223 @@ class Dispatcher {
     });
     return worker;
   }
+
+  _optimizeTestOrder(testGroups) {
+  const testsByDeviceCount = {};
+  testGroups.forEach(group => {
+    const devices = this._getJobDeviceRequirement(group);
+    if (!testsByDeviceCount[devices]) {
+      testsByDeviceCount[devices] = [];
+    }
+    testsByDeviceCount[devices].push(group);
+  });
+  
+  const poolSize = this._devicePool.total;
+  const workers = this._config.config.workers;
+  
+  console.log(`🧠 [OPTIMIZER] Optimizing for ${poolSize} devices and ${workers} workers`);
+  
+  // Log what we have to work with
+  const summary = {};
+  Object.entries(testsByDeviceCount).forEach(([devices, tests]) => {
+    summary[`${devices}-device`] = tests.length;
+  });
+  console.log(`    Test distribution:`, summary);
+  
+  const optimizedOrder = [];
+  
+  // SMART STRATEGY: Optimize for your specific setup
+  if (poolSize === 4) {
+    // For 4 devices: Prioritize what actually uses all devices efficiently
+    
+    // 1. Start with 2x 2-device tests (uses all 4 devices)
+    while (testsByDeviceCount[2]?.length >= 2) {
+      optimizedOrder.push(
+        testsByDeviceCount[2].shift(),
+        testsByDeviceCount[2].shift()
+      );
+    }
+    
+    // 2. Then 4-device tests (uses all devices with 1 worker)
+    if (testsByDeviceCount[4]) {
+      optimizedOrder.push(...testsByDeviceCount[4]);
+      delete testsByDeviceCount[4];
+    }
+    
+    // 3. Then 1x 3-device + 1x 1-device pairs (uses all 4 devices)
+    while (testsByDeviceCount[3]?.length > 0 && testsByDeviceCount[1]?.length > 0) {
+      optimizedOrder.push(
+        testsByDeviceCount[3].shift(),
+        testsByDeviceCount[1].shift()
+      );
+    }
+    
+    // 4. Then 4x 1-device tests (uses all 4 devices)
+    while (testsByDeviceCount[1]?.length >= 4) {
+      optimizedOrder.push(
+        testsByDeviceCount[1].shift(),
+        testsByDeviceCount[1].shift(),
+        testsByDeviceCount[1].shift(),
+        testsByDeviceCount[1].shift()
+      );
+    }
+    
+    // 5. Remaining 2-device tests
+    if (testsByDeviceCount[2]) {
+      optimizedOrder.push(...testsByDeviceCount[2]);
+    }
+    
+    // 6. Remaining 3-device tests
+    if (testsByDeviceCount[3]) {
+      optimizedOrder.push(...testsByDeviceCount[3]);
+    }
+    
+    // 7. Remaining 1-device tests
+    if (testsByDeviceCount[1]) {
+      optimizedOrder.push(...testsByDeviceCount[1]);
+    }
+    
+  } else if (poolSize === 12) {
+    // For 12 devices: Different strategy
+    
+    // 1. All 1-device tests first (can run 12 in parallel!)
+    if (testsByDeviceCount[1]) {
+      optimizedOrder.push(...testsByDeviceCount[1]);
+      delete testsByDeviceCount[1];
+    }
+    
+    // 2. Then 2-device tests (can run 6 in parallel)
+    if (testsByDeviceCount[2]) {
+      optimizedOrder.push(...testsByDeviceCount[2]);
+      delete testsByDeviceCount[2];
+    }
+    
+    // 3. Then larger tests in ascending order
+    for (let size = 3; size <= 12; size++) {
+      if (testsByDeviceCount[size]) {
+        optimizedOrder.push(...testsByDeviceCount[size]);
+      }
+    }
+  } else {
+    // Generic: Prioritize smaller tests for better parallelism
+    const sizes = Object.keys(testsByDeviceCount).map(Number).sort((a, b) => a - b);
+    for (const size of sizes) {
+      optimizedOrder.push(...testsByDeviceCount[size]);
+    }
+  }
+  
+  // Add any remaining tests
+  Object.values(testsByDeviceCount).forEach(tests => {
+    if (tests && tests.length > 0) {
+      optimizedOrder.push(...tests);
+    }
+  });
+  
+  // Log optimization result
+  const preview = optimizedOrder.slice(0, 20).map(job => 
+    this._getJobDeviceRequirement(job)
+  );
+  console.log(`    Optimized order (first 20): [${preview.join(', ')}] devices`);
+  
+  // Calculate expected efficiency
+  this._logExpectedEfficiency(optimizedOrder);
+  
+  return optimizedOrder;
+}
+
+_logExpectedEfficiency(orderedTests) {
+  const poolSize = this._devicePool.total;
+  const workers = this._config.config.workers;
+  
+  // Simulate first few "waves" of test execution
+  let wave = 1;
+  let index = 0;
+  let totalWastedSlots = 0;
+  
+  console.log(`    Expected execution waves:`);
+  
+  while (index < orderedTests.length && wave <= 3) {
+    let devicesUsed = 0;
+    let testsInWave = [];
+    
+    // Try to pack tests into this wave
+    for (let i = index; i < orderedTests.length && testsInWave.length < workers; i++) {
+      const testDevices = this._getJobDeviceRequirement(orderedTests[i]);
+      if (devicesUsed + testDevices <= poolSize) {
+        devicesUsed += testDevices;
+        testsInWave.push(testDevices);
+        index++;
+      }
+    }
+    
+    const utilization = Math.round((devicesUsed / poolSize) * 100);
+    const wastedSlots = poolSize - devicesUsed;
+    totalWastedSlots += wastedSlots;
+    
+    console.log(`      Wave ${wave}: [${testsInWave.join(', ')}] devices = ${devicesUsed}/${poolSize} (${utilization}% utilization)`);
+    wave++;
+  }
+  
+  console.log(`    Total device slots wasted in first 3 waves: ${totalWastedSlots}`);
+}
+  // Calculate optimal priority order based on pool size
+  _calculatePriorityOrder(poolSize) {
+    // For a 4-device pool, optimal order might be:
+    // - 2-device tests (can run 2 in parallel)
+    // - 1-device tests (fill gaps)
+    // - 3-device tests (leaves 1 device for small tests)
+    // - 4-device tests (blocks everything)
+    
+    if (poolSize === 4) {
+      return [2, 1, 3, 4];
+    } else if (poolSize === 8) {
+      return [4, 2, 3, 1, 6, 5, 7, 8];
+    } else if (poolSize === 12) {
+      return [4, 3, 2, 6, 1, 8, 5, 7, 9, 10, 11, 12];
+    } else {
+      // Generic strategy: middle values first, then small, then large
+      const order = [];
+      const middle = Math.floor(poolSize / 2);
+      
+      // Add middle values (best for parallel execution)
+      for (let i = middle; i > 0; i--) {
+        if (i <= poolSize) order.push(i);
+      }
+      
+      // Add larger values
+      for (let i = middle + 1; i <= poolSize; i++) {
+        order.push(i);
+      }
+      
+      return order;
+    }
+  }
+
+  // Optional: Add a method to analyze and report on the optimization
+  _analyzeTestDistribution() {
+    const distribution = {};
+    let totalDeviceTime = 0;
+    
+    this._queue.forEach(group => {
+      const devices = this._getJobDeviceRequirement(group);
+      distribution[devices] = (distribution[devices] || 0) + 1;
+      // Rough estimate: assume each test takes similar time
+      totalDeviceTime += devices;
+    });
+    
+    const theoreticalMinTime = totalDeviceTime / this._devicePool.total;
+    console.log(`📊 [ANALYSIS] Test distribution:`);
+    Object.entries(distribution).forEach(([devices, count]) => {
+      console.log(`    ${devices}-device tests: ${count}`);
+    });
+    console.log(`    Theoretical minimum time: ${Math.round(theoreticalMinTime)} test durations`);
+    console.log(`    Efficiency target: Keep all ${this._devicePool.total} devices busy`);
+  }
+
   producedEnvByProjectId() {
     return this._producedEnvByProjectId;
   }
+
   async stop() {
     if (this._isStopped)
       return;
@@ -201,6 +1156,7 @@ class Dispatcher {
     this._checkFinished();
   }
 }
+
 class JobDispatcher {
   constructor(job, reporter, failureTracker, stopCallback) {
     this.jobResult = new import_utils.ManualPromise();
